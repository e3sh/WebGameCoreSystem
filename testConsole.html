<!DOCTYPE html>

<html>
<head>
    <meta charset="utf-8" />
    <script src= "include.js" type="text/javascript"></script>
    <script type="text/javascript">
    // main
    //----------------------------------------------------------------------
    function main() {

        const sysParam = {
            canvasId: "layer0",
            screen: [ 
                { resolution: { w: 640, h: 480 , x:0, y:0 } },
                { resolution: { w: 640, h: 480 , x:0, y:0 } }
            ]
        }
        const game = new GameCore( sysParam );

        //Game Asset Setup
        pictdata(game);

        game.kanji = new fontPrintControl(
            game
            ,game.asset.image["ASCII"].img,	 6, 8
            ,game.asset.image["JISLV1"].img,12, 8
        )

        const c0 = new textConsole(50,15);  
		c0.setFontId("wide");
		//c0.setPrompt( ["#" ,"_"]);
		c0.setLinewidth(15);
		c0.setCharwidth(8);

        const c1 = new textConsole(50,35);  
		c1.setFontId("std");
		c1.setPrompt( ["#" ,"_"]);
		c1.setLinewidth(10);
		c1.setCharwidth(6);

        const textConsl = [c0, c1];

        game.textScreen = textConsl;

        //Game Task Setup
        game.task.add(new GameTask_Main("main"));

        //
        game.screen[0].setBackgroundcolor("black");//"Navy"); 
        game.screen[0].setInterval(1); 

        game.run();
    }

    //----------------------------------------------------------------------
    //Image Asset Setup
    function pictdata(g){
        g.asset.imageLoad( "JISLV1" ,"pict/k12x8_jisx0208c.png");
        g.asset.imageLoad( "ASCII"  ,"pict/k12x8_jisx0201c.png");
        g.asset.imageLoad( "ASC8x8"  ,"pict/font.png");
        //g.asset.imageLoad( "ASCII"  ,"pict/cha.png");

        let sp = [];
        for (let i = 2; i < 13; i++) {
            for (j = 0; j <16; j++) {
                ptn = { x:  6 * j, y: 8 * i, w:  6, h: 8};
                sp.push(ptn);
            }
        }
        //8_8_font
        g.setSpFont({ name: "std", id: "ASCII", pattern: sp });

        sp = [];
        for (let i = 0; i < 7; i++) {
            for (j = 0; j <16; j++) {
                ptn = { x:  8 * j, y: 8 * i, w:  8, h: 8};
                sp.push(ptn);
            }
        }
        //8_8_font
        g.setSpFont({ name: "wide", id: "ASC8x8", pattern: sp });
    }

    // ----------------------------------------------------------------------
    // GameTask
    class GameTask_Main extends GameTask {

        scene;

        txt;
        gfunc;

        count;

        constructor(id){
            super(id);
        }
        //----------------------------------------------------------------------
        pre(g){// 最初の実行時に実行。
            this.scene = [];

            this.scene[	"Gpad"	] = new SceneGPad();
            this.scene[	"VGpad"	] = new SceneVGPad(g);
 

            g.kanji.useScreen(0);

            g.beep.oscSetup(1);

            let note = g.beep.createNote(1);
            note.on(0);

            let score =["C5","C6"];
            let s = g.beep.makeScore(score, 100, 1);
            note.play(s, g.time()+500);


            let pixelRatioBox = document.querySelector(".pixel-ratio");

            const updatePixelRatio = () => {
                let pr = window.devicePixelRatio;
                let prString = (pr * 100).toFixed(0);
                pixelRatioBox.innerText = `${prString}% (${pr.toFixed(2)})`;
                matchMedia(`(resolution: ${pr}dppx)`).addEventListener(
                    "change",
                    updatePixelRatio,
                    { once: true },
                );
            };

            updatePixelRatio();

            //g.keyboard.codeMode();

            g.screen[0].assignFont("32px 'Arial'");//test
            g.screen[1].setInterval(1);

            this.count = 0;
        }
        //----------------------------------------------------------------------
        step(g){// this.enable が true時にループ毎に実行される。

            const RESO_X = 640;
            const RESO_Y = 480;

            // Input Keyboard ENTRY Check (oldtype) /g.keyboard.akey etc (newtype)
            let w = g.keyboard.check();

            let akey = false; if (Boolean(w[65])) {if (w[65]) akey = true;}
            let dkey = false; if (Boolean(w[68])) {if (w[68]) dkey = true;}
            let wkey = false; if (Boolean(w[87])) {if (w[87]) wkey = true;}
            let skey = false; if (Boolean(w[83])) {if (w[83]) skey = true;}
            let qkey = false; if (Boolean(w[81])) {if (w[81]) qkey = true;}
            let ekey = false; if (Boolean(w[69])) {if (w[69]) ekey = true;}

            let upkey	 = false; if (Boolean(w[38])) {if (w[38]) upkey	  = true;}
            let downkey  = false; if (Boolean(w[40])) {if (w[40]) downkey = true;}
            let leftkey  = false; if (Boolean(w[37])) {if (w[37]) leftkey = true;}
            let rightkey = false; if (Boolean(w[39])) {if (w[39]) rightkey= true;}

            let spacekey = false; if (Boolean(w[32])) {if (w[32]) spacekey= true;}
            let zkey = false; if (Boolean(w[90])) {if (w[90]) zkey= true;}

            let homekey = false; if (Boolean(w[36])) {if (w[36]) homekey = true;}
            let pkey = false; if (Boolean(w[80])) {if (w[80]) pkey = true;}

            // Input GamePad ENTRY Check
            let r = g.gamepad.check();

            let lb = g.gamepad.btn_lb;
            let rb = g.gamepad.btn_rb;
            let abtn = g.gamepad.btn_a;
            let xbtn = g.gamepad.btn_x;
                    
            let backbtn = g.gamepad.btn_back;
            
            let ar = g.gamepad.r;
            let axes = g.gamepad.axes;

            upkey	= (upkey	|| wkey)?true:false;
            downkey = (downkey	|| skey)?true:false;
            leftkey = (leftkey	|| akey)?true:false;
            rightkey = (rightkey|| dkey)?true:false;

            let fullscr = (homekey || backbtn)?true:false;
            if (fullscr){
                if (!document.fullscreenElement){ 
                    g.systemCanvas.requestFullscreen();
            }
                //g.mouse.mode(g);
            }
            g.mouse.mode(g); //FullScreen用の座標補正チェック
            // Input Mouse ENTRY Check
            let mstate = g.mouse.check();
            /*
            if ((mstate.x != this._sm.old_x)||(mstate.x != this._sm.old_x)){
                this._x = mstate.x;
                this._y = mstate.y;
                this._sm.old_x = mstate.x;
                this._sm.old_y = mstate.y;
            }
            let whl = false; 
            let whr = false;
            /* 
            if (mstate.wheel != 0) {
                whl = (Math.sign(mstate.wheel)<0)?true:false;
                whr = (Math.sign(mstate.wheel)>0)?true:false;
            }
            */
            // Input VGpad ENTRY
            g.touchpad.mode(g);

            let v = g.vgamepad.check();

            let vLbtn = false; if (Boolean(v.button[0])) {if (v.button[0]) vLbtn = true;}
            let vRbtn = false; if (Boolean(v.button[1])) {if (v.button[1]) vRbtn = true;}
            let vUbtn = false; if (Boolean(v.button[2])) {if (v.button[2]) vUbtn = true;}
            let vDbtn = false; if (Boolean(v.button[3])) {if (v.button[3]) vDbtn = true;}

            //Input Mixing
            if (r && (ar != -1)){

                //let vx = Math.trunc(axes[0]*30);
                //let vy = Math.trunc(axes[1]*30);

                //vx = (Math.abs(vx) > 3)? vx:0; vy = (Math.abs(vy) > 3)?vy:0; //StickのDrift対応　閾値10％

                this._x = axes[0];//this._x + vx;
                this._y = axes[1];//this._y + vy;
            }else if (v.distance != -1){
                let r = (v.deg-90) * (Math.PI / 180.0);

                this._x = Math.cos(r);//this._x + vx;
                this._y = Math.sin(r);//this._y + vy;

                //console.log("" + r + "," + this._x + "," + this._y);

            } else {
                this._x = (leftkey)?-1:(rightkey)?1:0;//this._x + vx;
                this._y = (upkey)?-1:(downkey)?1:0;//this._y + vy;
            }

            let leftbutton = (lb || zkey || qkey || vLbtn);// || whl);
            let rightbutton = (rb || zkey|| ekey || vRbtn);// || whr);
            let trigger = (abtn || xbtn || spacekey || vDbtn);// || (mstate.button == 0));

            let input = {x: this._x, y:this._y, trigger: trigger, left: leftbutton, right: rightbutton, keycode: w, mouse: mstate };

            this.scene["Gpad"].step(g, input, null);
            this.scene["VGpad"].step(g, input, null);

            let result = g.fpsload.result();

            let rstl = [];
            rstl.push("= information: GameCore.fpsload.result() =");
            rstl.push("FPS:" + result.fps);
            rstl.push("interval.log.length:" + result.interval.log.length);
            rstl.push("interval.log[0]:" + result.interval.log[0]);
            rstl.push("interval.max:" + result.interval.max);
            rstl.push("interval.min:" + result.interval.min);
            rstl.push("interval.ave:" + result.interval.ave);
            rstl.push("workload.log.length:" + result.workload.log.length);
            rstl.push("workload.log[0]" + result.workload.log[0]);
            rstl.push("workload.max:" + result.workload.max);
            rstl.push("workload.min:" + result.workload.min);
            rstl.push("workload.ave:" + result.workload.ave);
            let p = (result.workload.ave/result.interval.ave)*100;
            rstl.push("-- (workload.ave/interval.ave)*100 --");
            rstl.push("workload(%) :" + p);

            this.txt = rstl;

            this.gfunc = new pfmclass(result, 560, 100, 2.5);

            let f = leftbutton || rightbutton || trigger
            if (!f) {
                this.count++;
            }else{
                g.textScreen[1].clear();
                for (let i in rstl){
                    let s = rstl[i];
                    //g.textScreen[0].mvprintw(s, 0, i);
                    g.textScreen[1].move(0, Math.trunc(12+Number(i)));
                    g.textScreen[1].printw(s);
                }
            }

            if (this.count < 15) return;
            g.textScreen[1].scrolllock(false);
            g.textScreen[1].wscrl(15);
            
            g.textScreen[0].move(0, 0);
            g.textScreen[0].insertln();

            this.count = 0;

            for (let i in rstl){
                let s = rstl[i];
                //g.textScreen[0].mvprintw(s, 0, i);
                g.textScreen[1].move(0, Math.trunc(22+Number(i)));
                g.textScreen[1].printw(s);
            }
            let wi = rstl.length-1;

            let s = `- ${rstl[1].substring(0,10)} / ${rstl[wi].substring(0,20)}`; 

            g.textScreen[0].mvprintw(s, 0, 0);
            g.textScreen[0].move(0, 0);
            //g.textScreen[0].mvprintw(rstl[1], 0, 21);
            //g.textScreen[0].move(0, 0);
        }
        //----------------------------------------------------------------------
        draw(g){// this.visible が true時にループ毎に実行される。
            g.kanji.print(" 起動OK",0,8);

            let t = g.time();
            g.kanji.print(" runtime:" + Math.trunc(t),0,16);
            g.kanji.print(" deltaTime:" + g.deltaTime().toString().substring(0,5),0,24);

            if (document.fullscreenElement){
            g.kanji.print("FullScreen:" + document.fullscreenElement?.nodeName, 120, 8); 
            }
            
            let cw = document.documentElement.clientWidth;
            let ch = document.documentElement.clientHeight;
            let pixr = window.devicePixelRatio;

            g.kanji.print("c-width:"  + cw, 120, 16);
            g.kanji.print("c-height:" + ch, 120, 24);
            g.kanji.print("devPixelRatio:" + pixr, 120, 32);

            g.kanji.print("canvas_w:" + g.systemCanvas.width, 240, 16);
            g.kanji.print("canvas_h:" + g.systemCanvas.height,240, 24);

            this.scene["Gpad"].draw(g);
            this.scene["VGpad"].draw(g);

            for (let i in this.txt){
                //g.screen[0].print(this.txt[i],360, i*14+10);
                //g.kanji.print(this.txt[i],360, 240 + i*10);
            }
            g.textScreen[0].draw(g, 0, 200);
            g.textScreen[1].draw(g, 320, 50);

            g.screen[1].putFunc( this.gfunc );

            let sl =[];
            sl.push("sc(i)bgCol/max/cnt");  
            for (let i in g.screen){
                sl.push(` ${i}(${g.screen[i].getInterval()})${g.screen[i].getBackgroundcolor()}/${g.screen[i].max()}/${g.screen[i].count()}`);
            }
            for (let i in sl){
                g.kanji.print(sl[i],360, 400 + i*10);
            }

        }
    }
    //----------------------------------------------------------------------
    // GPadScene(I/Ostatus)
    function SceneGPad(){

        const X = 0;
        const Y = 48;

        let st;

        this.step = function(g, i, p){

            st = g.gamepad.infodraw()

            let k = i.keycode;

            let ws = "";
            for (let i in k){
                if (Boolean(k[i])){
                    ws += "[" + i + "]";//+ (k[i]?"o":".");
                }
            } 
            let ms = "";
            let m = i.mouse;
            ms = "x:" + m.x + ", y:" + m.y + ", w:" + m.wheel + ", btn:" + m.button;

            let t = g.touchpad.check_last();

            st.push("");
            st.push("[Keyboard]");
            st.push(ws);

            st.push("");
            st.push("[Mouse]");
            st.push(ms);

            st.push("");
            st.push("[TouchPad]");
            st.push("Cnt:" + t.pos.length);
            if ( t.pos.length >0 ){
                for (let i in t.pos){
                    st.push("[" + i +"]" + Object.entries(t.pos[i]));//.x + "," + t.pos[i].y);
                }
            }
        }
        this.draw = function(g){

            for (let i in st){
                g.kanji.print(st[i],X, Y+i*8);
            }
        }
    }
    //----------------------------------------------------------------------
    // VGPadScene(I/Ostatus)
    function SceneVGPad(g){

        const X=0;
        const Y=g.screen[0].ch-48;

        let st;

        this.step = function(g, i, p){

            let s = g.vgamepad.check();

            st = [];

            st.push("state button:" + s.button);
            st.push("state deg   :" + s.deg);
            st.push("state distance:" + s.distance);

            st.push("canvas_w:" + g.systemCanvas.width);
            st.push("canvas_h:" + g.systemCanvas.height);

            m = i.mouse;
        }
        this.draw = function(g){

            g.vgamepad.draw(g.screen[0]);

            let cl = {};
            cl.draw = function(device){
                device.globalAlpha = 1.0;
            }
            g.screen[0].putFunc(cl);


            g.mouse.draw(g.screen[0]);
            g.touchpad.draw(g.screen[0]);

            for (let i in st){
            	g.kanji.print(st[i],X, Y+i*8);
            }
        }
    }
    //-------------------------------
    // performance metor circle
    /**
     * performance metor circle 
     * @param {resultlog} result = GameCore.fpsload.result();
     * @param {number} x circle center x　
     * @param {number} y circle center y
     * @param {number} m mag
     * @description
     * resultlog circle graph Demonstration
     * type{putFuncCustomDraw}
     * use example: GameCore.screen[x].putFunc(new pfmclass(result, x, y));
     * 
     */
    function pfmclass(result, x, y, m){

        let pdata = [];
        let cdata = [];

        pdata.push(result.interval.log);
        pdata.push(result.workload.log);

        //cdata.push(result.interval.max);
        //cdata.push(result.interval.min);
        cdata.push(result.interval.ave);
        cdata.push(result.workload.max);
        cdata.push(result.workload.min);
        //cdata.push(result.workload.ave);

        this.data = pdata;
        this.dcdt = cdata;
        this.cx = x;
        this.cy = y;

        let r = (Math.PI*2)/result.fps;
        this.wx = x + Math.cos(r*result.logpointer)*result.interval.ave*m;
        this.wy = y + Math.sin(r*result.logpointer)*result.interval.ave*m;

        this.ix = x + Math.cos(r*result.logpointer)*result.workload.max*m;
        this.iy = y + Math.sin(r*result.logpointer)*result.workload.max*m;

        this.draw =(device)=>{

            for (let d of this.dcdt){
                device.beginPath();
                device.lineWidth = 1;
                device.strokeStyle = "yellow";

                device.arc(this.cx, this.cy, d*m, 0, Math.PI*2, true);
                device.stroke();
            }

            for (let d of pdata){
                let x = this.cx;
                let y = this.cy;

                let r = (Math.PI*2)/d.length;
            
                device.beginPath();
                device.lineWidth = 1;
                device.strokeStyle = "red";

                for (let i=0; i<d.length; i++){
                    x = this.cx + Math.cos(r*i)*d[i]*m;
                    y = this.cy + Math.sin(r*i)*d[i]*m;
                
                    if (i==0) {
                        device.moveTo(x,y);
                    }else{
                        device.lineTo(x,y);
                        device.stroke(); 
                    }
                }
                device.closePath();
                device.stroke();                
            }

            device.beginPath();
            device.lineWidth = 3;
            device.strokeStyle = "orange";
            device.moveTo(this.ix, this.iy);
            device.lineTo(this.wx, this.wy);
            device.closePath();
            device.stroke(); 
        }
    }
    

    </script>
    <title>[wGcsTestConsole]</title>
    <style>
        * {
            margin:0; padding:0;
        } 
        .resizeimage * { width: 100%; }
    </style>
</head>
<body>
    <canvas id="layer0" oncontextmenu="return false;">
    layer-0
    </canvas>
    <br>
    <input type="button" id="btn" value="start" onclick="main()">
    <div class="pixel-ratio"></div>
</body>
</html>